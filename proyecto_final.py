# -*- coding: utf-8 -*-
"""proyecto_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lbtw-aAL2SnDqupqlwt-2gIjZw43osU5

Montamos el Drive
"""

import os
from google.colab import drive

path_ai = "Proyecto_Final" #@param {type:"string"}
path = "/content/drive/MyDrive/" + path_ai
drive.mount('/content/drive')
os.chdir(path)
print(os.getcwd())

"""Importamos las librer√≠as"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
sns.set_theme()
pd.__version__

!pip install pandas-profiling

"""ZONA DE TRABAJO"""

dataset = pd.read_csv("heart_dataset.csv",sep=",")
print(dataset.shape)
dataset.head(100)

dataset.info()

"""![image.png](data:image/png;base64,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)"""

cantidad_personas_con_ataque = dataset['HeartDiseaseorAttack'].sum()

print("Cantidad de personas con ataque al coraz√≥n:", cantidad_personas_con_ataque)

"""Matriz de Correlaci√≥n, se puede ver que las variables en general no se encuentran muy relacionadas."""

sns.heatmap(dataset.corr())

#NUEVO DATA SET CON CORRELACIONES ALTAS DIRECTAMENTES Y CON CORRELACIONES BAJAS INVERSAMENTE

# DATA SET CON LAS SIGUIENTES CARACTERISTICAS = HighBP, HighChol, Smoker, Stroke, Diabetes, PhysActivity,GenHlth,PhysHlth,DiffWalk,Sex,Age,Education,Income

data_hc = dataset[['Age','DiffWalk','GenHlth','Stroke','HighChol','Diabetes','Smoker','PhysHlth','HighBP','Sex','PhysActivity','Education','Income','HeartDiseaseorAttack']]
data_hc.head()

import pandas as pd
from sklearn.utils import shuffle

# Crear una copia del conjunto de datos original para evitar modificar el conjunto original
dataset_copy = data_hc.copy()

# Filtrar las primeras 5000 muestras de la clase 0 y 5000 de la clase 1 para el conjunto de prueba
test_samples_class_0 = dataset_copy[dataset_copy['HeartDiseaseorAttack'] == 0].head(5000)
test_samples_class_1 = dataset_copy[dataset_copy['HeartDiseaseorAttack'] == 1].head(5000)

# Concatenar las muestras de prueba
test_data = pd.concat([test_samples_class_0, test_samples_class_1])

# Eliminar las muestras de prueba del conjunto de datos original para obtener el conjunto de entrenamiento
data_hc = dataset_copy.drop(test_data.index)

# Imprimir la informaci√≥n sobre la divisi√≥n
print("Conjunto de entrenamiento:", data_hc.shape)
print("Conjunto de prueba:", test_data.shape)

# Guardar los conjuntos de entrenamiento y prueba si es necesario
data_hc.to_csv('train_data.csv', index=False)
test_data.to_csv('test_data.csv', index=False)

data_hc = shuffle(data_hc, random_state=1)

count_class_0 = data_hc['HeartDiseaseorAttack'].value_counts().get(0, 0)
count_class_1 = data_hc['HeartDiseaseorAttack'].value_counts().get(1, 0)

print("N√∫mero de datos de la clase 0 en el conjunto de entrenamiento:", count_class_0)
print("N√∫mero de datos de la clase 1 en el conjunto de entrenamiento:", count_class_1)
data_hc.head(20)

test_data_shuffled = shuffle(test_data, random_state=21)
test_data_shuffled.head()

sns.heatmap(data_hc.corr())

data_hc.head(10)

correlation = dataset['Age'].corr(dataset['HeartDiseaseorAttack'])

print("Correlaci√≥n entre  y HeartAttack:", correlation)

import matplotlib.pyplot as plt
import seaborn as sns

# Crear un gr√°fico de barras
plt.figure(figsize=(10, 6))
sns.countplot(x='Age', hue='HeartDiseaseorAttack', data=data_hc)
plt.title('Relaci√≥n entre Grupos de Edad y Ataques al Coraz√≥n')
plt.xlabel('Grupo de Edad')
plt.ylabel('N√∫mero de Personas')
plt.legend(title='Ataque al Coraz√≥n', loc='upper right', labels=['No', 'S√≠'])
plt.show()

# Crear un diccionario para almacenar la cantidad de personas con ataques al coraz√≥n por grupo de edad
heart_attack_counts = {}

# Iterar a trav√©s de los grupos de edad del 1 al 13
for i in range(1, 14):
    # Filtrar el DataFrame para personas en el grupo de edad actual con ataques al coraz√≥n
    age_group_with_heart_attack = data_hc[(data_hc['Age'] == i) & (data_hc['HeartDiseaseorAttack'] == 1)]

    # Contar la cantidad de personas en el grupo de edad actual con ataques al coraz√≥n y guardar en el diccionario
    heart_attack_counts[f'Grupo {i}'] = len(age_group_with_heart_attack)

# Imprimir la cantidad de personas con ataques al coraz√≥n por grupo de edad
for group, count in heart_attack_counts.items():
    print(f'Cantidad de personas en {group} con ataques al coraz√≥n: {count}')

plt.plot(dataset.groupby("Age").count())
plt.ylabel("Frecuencia")
plt.xlabel("Grupo de edad")

data_hc.groupby("GenHlth").count()

import matplotlib.pyplot as plt
import seaborn as sns

# Crear un gr√°fico de barras
plt.figure(figsize=(10, 6))
sns.countplot(x='GenHlth', hue='HeartDiseaseorAttack', data=data_hc)
plt.title('Relaci√≥n entre Grupos de GenHlth y Ataques al Coraz√≥n')
plt.xlabel('Grupo de GenHlth')
plt.ylabel('N√∫mero de Personas')
plt.legend(title='Ataque al Coraz√≥n', loc='upper right', labels=['No', 'S√≠'])
plt.show()

# Crear un diccionario para almacenar la cantidad de personas con ataques al coraz√≥n por grupo de edad
heart_attack_counts = {}

# Iterar a trav√©s de los grupos de edad del 1 al 13
for i in range(1, 6):
    # Filtrar el DataFrame para personas en el grupo de edad actual con ataques al coraz√≥n
    age_group_with_heart_attack = data_hc[(data_hc['GenHlth'] == i) & (data_hc['HeartDiseaseorAttack'] == 1)]

    # Contar la cantidad de personas en el grupo de edad actual con ataques al coraz√≥n y guardar en el diccionario
    heart_attack_counts[f'Grupo {i}'] = len(age_group_with_heart_attack)

# Imprimir la cantidad de personas con ataques al coraz√≥n por grupo de edad
for group, count in heart_attack_counts.items():
    print(f'Cantidad de personas en {group} con ataques al coraz√≥n: {count}')

"""La mayor√≠a de edades se encuentran entre 45 y 70 a√±os, correspondiente a los grupos de edades entre los n√∫meros 6 y 10."""

import matplotlib.pyplot as plt
import seaborn as sns

# Crear un gr√°fico de barras
plt.figure(figsize=(10, 6))
sns.countplot(x='DiffWalk', hue='HeartDiseaseorAttack', data=data_hc)
plt.title('Relaci√≥n entre Grupos de DiffWalk y Ataques al Coraz√≥n')
plt.xlabel('Grupo de DiffWalk')
plt.ylabel('N√∫mero de Personas')
plt.legend(title='Ataque al Coraz√≥n', loc='upper right', labels=['No', 'S√≠'])
plt.show()

data_hc.groupby("DiffWalk").count()

# Crear un diccionario para almacenar la cantidad de personas con ataques al coraz√≥n por grupo de edad
heart_attack_counts = {}

# Iterar a trav√©s de los grupos de edad del 1 al 13
for i in range(0, 2):
    # Filtrar el DataFrame para personas en el grupo de edad actual con ataques al coraz√≥n
    age_group_with_heart_attack = data_hc[(data_hc['DiffWalk'] == i) & (data_hc['HeartDiseaseorAttack'] == 1)]

    # Contar la cantidad de personas en el grupo de edad actual con ataques al coraz√≥n y guardar en el diccionario
    heart_attack_counts[f'Grupo {i}'] = len(age_group_with_heart_attack)

# Imprimir la cantidad de personas con ataques al coraz√≥n por grupo de edad
for group, count in heart_attack_counts.items():
    print(f'Cantidad de personas en {group} con ataques al coraz√≥n: {count}')

correlation = dataset['DiffWalk'].corr(dataset['HeartDiseaseorAttack'])

print("Correlaci√≥n entre  y HeartAttack:", correlation)

import matplotlib.pyplot as plt
import seaborn as sns

# Crear un gr√°fico de barras
plt.figure(figsize=(10, 6))
sns.countplot(x='Stroke', hue='HeartDiseaseorAttack', data=data_hc)
plt.title('Relaci√≥n entre Grupos de Stroke y Ataques al Coraz√≥n')
plt.xlabel('Grupo de Stroke')
plt.ylabel('N√∫mero de Personas')
plt.legend(title='Ataque al Coraz√≥n', loc='upper right', labels=['No', 'S√≠'])
plt.show()

# Crear un diccionario para almacenar la cantidad de personas con ataques al coraz√≥n por grupo de edad
heart_attack_counts = {}

# Iterar a trav√©s de los grupos de edad del 1 al 13

    # Filtrar el DataFrame para personas en el grupo de edad actual con ataques al coraz√≥n
age_group_with_heart_attack1 = data_hc[(data_hc['Stroke'] == 0) & (data_hc['HeartDiseaseorAttack'] == 0)]
age_group_with_heart_attack2 = data_hc[(data_hc['Stroke'] == 0) & (data_hc['HeartDiseaseorAttack'] == 1)]
age_group_with_heart_attack3 = data_hc[(data_hc['Stroke'] == 1) & (data_hc['HeartDiseaseorAttack'] == 0)]
age_group_with_heart_attack4 = data_hc[(data_hc['Stroke'] == 1) & (data_hc['HeartDiseaseorAttack'] == 1)]
    # Contar la cantidad de personas en el grupo de edad actual con ataques al coraz√≥n y guardar en el diccionario
heart_attack_counts[f'Grupo {1}'] = len(age_group_with_heart_attack1)
heart_attack_counts[f'Grupo {2}'] = len(age_group_with_heart_attack2)
heart_attack_counts[f'Grupo {3}'] = len(age_group_with_heart_attack3)
heart_attack_counts[f'Grupo {4}'] = len(age_group_with_heart_attack4)

# Imprimir la cantidad de personas con ataques al coraz√≥n por grupo de edad
for group, count in heart_attack_counts.items():
  print(f' {group} {count}')


#EL GRUPO 2 CON RESPECTO AL 1 REPRESENTA EL 8%

#EL GRUPO 4 CON RESPECTO AL 3 REPRESENTA EL 61%

import matplotlib.pyplot as plt
import seaborn as sns

# Crear un gr√°fico de barras
plt.figure(figsize=(10, 6))
sns.countplot(x='HighChol', hue='HeartDiseaseorAttack', data=data_hc)
plt.title('Relaci√≥n entre Grupos de HighChol y Ataques al Coraz√≥n')
plt.xlabel('Grupo de Stroke')
plt.ylabel('N√∫mero de Personas')
plt.legend(title='Ataque al Coraz√≥n', loc='upper right', labels=['No', 'S√≠'])
plt.show()

# Crear un diccionario para almacenar la cantidad de personas con ataques al coraz√≥n por grupo de edad
heart_attack_counts = {}

# Iterar a trav√©s de los grupos de edad del 1 al 13

    # Filtrar el DataFrame para personas en el grupo de edad actual con ataques al coraz√≥n
age_group_with_heart_attack1 = data_hc[(data_hc['HighChol'] == 0) & (data_hc['HeartDiseaseorAttack'] == 0)]
age_group_with_heart_attack2 = data_hc[(data_hc['HighChol'] == 0) & (data_hc['HeartDiseaseorAttack'] == 1)]
age_group_with_heart_attack3 = data_hc[(data_hc['HighChol'] == 1) & (data_hc['HeartDiseaseorAttack'] == 0)]
age_group_with_heart_attack4 = data_hc[(data_hc['HighChol'] == 1) & (data_hc['HeartDiseaseorAttack'] == 1)]
    # Contar la cantidad de personas en el grupo de edad actual con ataques al coraz√≥n y guardar en el diccionario
heart_attack_counts[f'Grupo {1}'] = len(age_group_with_heart_attack1)
heart_attack_counts[f'Grupo {2}'] = len(age_group_with_heart_attack2)
heart_attack_counts[f'Grupo {3}'] = len(age_group_with_heart_attack3)
heart_attack_counts[f'Grupo {4}'] = len(age_group_with_heart_attack4)

# Imprimir la cantidad de personas con ataques al coraz√≥n por grupo de edad
for group, count in heart_attack_counts.items():
  print(f' {group} {count}')


#EL GRUPO 2 CON RESPECTO AL 1 REPRESENTA EL 8%

#EL GRUPO 4 CON RESPECTO AL 3 REPRESENTA EL 61%

import matplotlib.pyplot as plt
import seaborn as sns

# Crear un gr√°fico de barras
plt.figure(figsize=(10, 6))
sns.countplot(x='Diabetes', hue='HeartDiseaseorAttack', data=data_hc)
plt.title('Relaci√≥n entre Grupos de Diabetes y Ataques al Coraz√≥n')
plt.xlabel('Grupo de Diabetes')
plt.ylabel('N√∫mero de Personas')
plt.legend(title='Ataque al Coraz√≥n', loc='upper right', labels=['No', 'S√≠'])
plt.show()

# Crear un diccionario para almacenar la cantidad de personas con ataques al coraz√≥n por grupo de edad
heart_attack_counts = {}

# Iterar a trav√©s de los grupos de edad del 1 al 13
for i in range(0, 3):
    # Filtrar el DataFrame para personas en el grupo de edad actual con ataques al coraz√≥n
    age_group_with_heart_attack = data_hc[(data_hc['Diabetes'] == i) & (data_hc['HeartDiseaseorAttack'] == 1)]

    # Contar la cantidad de personas en el grupo de edad actual con ataques al coraz√≥n y guardar en el diccionario
    heart_attack_counts[f'Grupo {i}'] = len(age_group_with_heart_attack)

# Imprimir la cantidad de personas con ataques al coraz√≥n por grupo de edad
for group, count in heart_attack_counts.items():
    print(f'Cantidad de personas en {group} con ataques al coraz√≥n: {count}')

import matplotlib.pyplot as plt
import seaborn as sns

# Crear un gr√°fico de barras
plt.figure(figsize=(10, 6))
sns.countplot(x='Income', hue='HeartDiseaseorAttack', data=data_hc)
plt.title('Relaci√≥n entre Grupos de Diabetes y Ataques al Coraz√≥n')
plt.xlabel('Grupo de Income')
plt.ylabel('N√∫mero de Personas')
plt.legend(title='Ataque al Coraz√≥n', loc='upper right', labels=['No', 'S√≠'])
plt.show()

data_hc.groupby("Income").count()

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline
pd.__version__

from pandas_profiling import ProfileReport
report = ProfileReport(dataset)
report.to_file(output_file='output.html')

#barajando los datos de testeo
test_data_shuffled = shuffle(test_data, random_state=21)
test_data_shuffled.head()

from sklearn.metrics import classification_report, f1_score, make_scorer
from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
from sklearn.metrics import *
import numpy as np
import pandas as pd

#diviviendo los datos de testeo

X_test_correct= test_data_shuffled.values[:,:-1]
y_test_correct=test_data_shuffled.values[:,-1]

#Usando los datos particionados de entrenamiento

X = data_hc.values[:,:-1]
y = data_hc.values[:,-1]
X_train, X_test, y_train, y_test = train_test_split(data_hc.iloc[:, :-1], data_hc['HeartDiseaseorAttack'], test_size=0.2, random_state=21, shuffle=True)
est = GaussianNB()

est.fit(X_train,y_train)
#usamos los testeos correspondientes
y_pred = est.predict(X_test_correct)
print(classification_report(y_test_correct, y_pred))

"""#**Segunda Entrega Proyecto final**

###**REPORTE DE CLASIFICACI√ìN GNB**

PRIMERA VISUALIZACION SIN OVERSAMPLING NI HYPER PARAMETROS
"""

from sklearn.metrics import classification_report, f1_score, make_scorer
from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
from sklearn.metrics import *
import numpy as np
import pandas as pd


X = data_hc.values[:,:-1]
y = data_hc.values[:,-1]
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2, shuffle= True, random_state=21)
est = GaussianNB()

est.fit(X_train,y_train)
y_pred = est.predict(X_test)
print(classification_report(y_test, y_pred))

"""SEGUNDA VISUALIZACION HACIENDO OVERSAMPLIG A LOS DATOS
DEBIDO A NUESTRA NECESIDAD DE AUMNETAR LA CLASE 1 DE CASOS EN LOS QUE ES POSITIVO PARA CANCER LE DECIMOS A SMOTE QUE QUEREMOS QUE DESPUES DE HACER EL OVERSAMPLIG NUESTRA CLASE 1 SEA EL 100% DE LA CLASE 0

POR EJEMPLO SI LA CLASE CERO TIENE 100 DATOS Y LA CLASE 1 TIENE 20 DESPUES DEL OVERSAMPLING LA CLASE 1 Y LA CLASE 0 TENDRAS 100 DATOS CADA UNA.

CON ESTE PROCESO HEMOS LOGRADO AUMENTAR AL EFICACIA DE NUESTRO MODELO DE OBTENER UN 0.37 EN EL RECALL A UN 0.71
"""

X_test_correct= test_data_shuffled.values[:,:-1]
y_test_correct=test_data_shuffled.values[:,-1]


from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE
from sklearn.decomposition import PCA

X = data_hc.values[:, :-1]
y = data_hc.values[:, -1]

# Crear una instancia de SMOTE
smote = SMOTE(sampling_strategy=1, random_state=42)

# Aplicar SMOTE a tus datos
X_resampled, y_resampled = smote.fit_resample(X, y)

# Dividir los datos transformados despu√©s de SMOTE y PCA
X_train, X_test, y_train, y_test = train_test_split(X_resampled, y_resampled, test_size=0.3, random_state=21)

# Crear una instancia del clasificador Gaussian Naive Bayes
est = GaussianNB()

# Entrenar el modelo
est.fit(X_train, y_train)

# Realizar predicciones en el conjunto de prueba
y_pred = est.predict(X_test_correct)

# Imprimir el informe de clasificaci√≥n
print(classification_report(y_test_correct, y_pred))

"""OVERSAMPLING + PCA

AHORA APLICAMOS UNA REDUCCI√ìN DE CARACTERISTICAS CON PCA, CON UN NUMERO DE COMPONENTES IGUAL A 8 LOGRAMOS MEJORAR UN POCO EL RESULTADO ANTERIOR CON SOLO OVERSAMPLING Y NOS DAMOS CUENTA QUE PARA 8 COMPONENTES EN ADELANTE SE MANTIENE IGUAL EN 0.75 SE LOGRO UNA PEQUE√ëA MEJORA.
"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE
from sklearn.decomposition import PCA

X = data_hc.values[:, :-1]
y = data_hc.values[:, -1]

# Crear una instancia de SMOTE
smote = SMOTE(sampling_strategy=1, random_state=42)

# Aplicar SMOTE a tus datos
X_resampled, y_resampled = smote.fit_resample(X, y)

X_pca = PCA(n_components=8)
X_pca = X_pca.fit_transform(X_resampled)

# Aplicar PCA al conjunto de prueba
x_train_pca = PCA(n_components=8)
X_test_correct_pca = x_train_pca.fit_transform(X_test_correct)

# Dividir los datos transformados despu√©s de SMOTE y PCA
X_train, X_test, y_train, y_test = train_test_split(X_pca, y_resampled, test_size=0.3, random_state=21)

# Crear una instancia del clasificador Gaussian Naive Bayes
est = GaussianNB()

# Entrenar el modelo
est.fit(X_train, y_train)

# Realizar predicciones en el conjunto de prueba
y_pred = est.predict(X_test_correct_pca)

# Imprimir el informe de clasificaci√≥n
print(classification_report(y_test_correct, y_pred))

"""GNB + TSNE"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from sklearn.naive_bayes import GaussianNB

# Tomar solo los primeros 1000 datos
subset_size = 10000
X_subset = X[:subset_size, :]
y_subset = y[:subset_size]

# Crear una instancia de SMOTE
smote = SMOTE(sampling_strategy=1, random_state=42)

# Aplicar SMOTE a tus datos
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)

# Aplicar PCA a los datos resampleados
pca = PCA(n_components=8)
X_pca = pca.fit_transform(X_resampled)

# Aplicar t-SNE a los datos transformados por PCA
tsne = TSNE(n_components=2, random_state=42)
X_tsne = tsne.fit_transform(X_pca)

# Dividir los datos transformados despu√©s de t-SNE
X_train, X_test, y_train, y_test = train_test_split(X_tsne, y_resampled, test_size=0.3, random_state=21)

# Crear una instancia del clasificador Gaussian Naive Bayes
est = GaussianNB()

# Entrenar el modelo
est.fit(X_train, y_train)

# Realizar predicciones en el conjunto de prueba
y_pred = est.predict(X_test)

# Imprimir el informe de clasificaci√≥n
print(classification_report(y_test, y_pred))

"""###**DECISION TREE CLASSIFIER (DTC)**



"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report

est = DecisionTreeClassifier(max_depth=6)

X = data_hc.values[:, :-1]
y = data_hc.values[:, -1]


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=True, random_state=21)
est.fit(X_train, y_train)

print(classification_report(y_test_correct, est.predict(X_test_correct), zero_division=0))

"""NUESTRO DESICION TREE CLASSIFIER NO DA DE ENTRADA UN RECALL PEOR QUE EL GNB SIN MODIFICACIONES, VEAMOS CUAL ES EL GRADO DE MEJORAR DESPUES DE LAS ACTUALIZACIONES QUE LE HICIEMOS AL GNB.

PRIMERO DTC CON OVERSAMPLING

Y NOTAMOS QUE AUNQUE EL F1-SCORE SI MEJORA CON RESPECTO AL GNB EL RECALL
"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report

est = DecisionTreeClassifier(max_depth=10)

X = data_hc.values[:, :-1]
y = data_hc.values[:, -1]

smote = SMOTE(sampling_strategy=1, random_state=42)

# Aplicar SMOTE a tus datos
X_resampled, y_resampled = smote.fit_resample(X, y)

X_train, X_test, y_train, y_test = train_test_split(X_resampled, y_resampled, test_size=0.3, shuffle=True, random_state=21)
est.fit(X_train, y_train)

print(classification_report(y_test_correct, est.predict(X_test_correct), zero_division=0))

"""COMO PRETENDEMOS USAR UNA PROFUNDIDAD Y HYPERPARAMETROS MAS ROBUSTOS QUE PUEDEN CAER EN UNA COMPLEJIDAD MAYOR DIVIDIMOS LOS DATOS PARA TOMAR SOLO PEUQE√ëAS MUESTRAS, COMO YA LA FUNCION SHUFFLE ESTA EN EL TRAIN TEST SPLIT NO HAY PROBLEMAS AL HACER ESTO.

Y VEMOS QUE CON MAS PROFUNDIDAD Y UN MUESTREO DE DATOS DE 10000 LOGRAMOS OBTENER UNA MEJORA MUY CONSIDERABLE DE 0.91 CON RECPECTO AL 0.76 DE GNB.

NOTA: TOMAMOS LA MEJOR PRFUNDIDAD, AL AUMENTARLA DE 18 NO CAMBIARA NADA M√ÅS
"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE

# Crear un clasificador de √°rbol de decisi√≥n
est = DecisionTreeClassifier(max_depth=6)

# Tomar solo los primeros x datos
subset_size = 200000
X_subset = X[:subset_size, :]
y_subset = y[:subset_size]

# Aplicar SMOTE a tus datos
smote = SMOTE(sampling_strategy=1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)

# Dividir los datos transformados despu√©s de SMOTE
X_train, X_test, y_train, y_test = train_test_split(X_resampled, y_resampled, test_size=0.3, shuffle=True, random_state=21)

# Entrenar el modelo
est.fit(X_train, y_train)

# Imprimir el informe de clasificaci√≥n
print(classification_report(y_test_correct, est.predict(X_test_correct), zero_division=0))

"""DTC + PCA

NUESTRA CONCLUSION CON RESPECTO AL DTC Y SU CLARA DESMEJORA CON EL PCA ES QUE ESTE SE BENEFICIA DE TENER CARACTERISCAS ASI PUEDE HACER MEJOR SUS RAMAS.
"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE

# Crear un clasificador de √°rbol de decisi√≥n
est = DecisionTreeClassifier(max_depth=6)

# Tomar solo los primeros 1000 datos
subset_size = 100000
X_subset = X[:subset_size, :]
y_subset = y[:subset_size]

# Aplicar SMOTE a tus datos
smote = SMOTE(sampling_strategy=1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)

X_pca = PCA(n_components=8)
X_pca = X_pca.fit_transform(X_resampled)

# Aplicar PCA al conjunto de prueba
x_train_pca = PCA(n_components=8)
X_test_correct_pca = x_train_pca.fit_transform(X_test_correct)

# Dividir los datos transformados despu√©s de SMOTE
X_train, X_test, y_train, y_test = train_test_split(X_pca, y_resampled, test_size=0.3, shuffle=True, random_state=21)

# Entrenar el modelo
est.fit(X_train, y_train)

# Imprimir el informe de clasificaci√≥n
print(classification_report(y_test_correct, est.predict(X_test_correct_pca), zero_division=0))

"""DTC + TSNE EL USO DEL TSNE MANDA LA COMPLEJIDAD POR LOS CIELOS POR ENDE TENDREMOS QUE CONFORMARNOS CON USAR SOLO UN SUBCONJUNTO DE 1000 DATOS, A PESAR DE ESTO SE NOTA UNA LEVE MEJORA.

"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE

# Crear un clasificador de √°rbol de decisi√≥n
est = DecisionTreeClassifier(max_depth=18)

# Tomar solo los primeros 100,000 datos
subset_size = 10000
X_subset = X[:subset_size, :]
y_subset = y[:subset_size]

# Aplicar SMOTE a tus datos
smote = SMOTE(sampling_strategy=1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)

# Aplicar PCA a los datos resampleados
pca = PCA(n_components=8)
X_pca = pca.fit_transform(X_resampled)

# Aplicar t-SNE a los datos transformados por PCA
tsne = TSNE(n_components=2, random_state=42)
X_tsne = tsne.fit_transform(X_pca)

# Dividir los datos transformados despu√©s de t-SNE
X_train, X_test, y_train, y_test = train_test_split(X_tsne, y_resampled, test_size=0.3, shuffle=True, random_state=21)

# Entrenar el modelo
est.fit(X_train, y_train)

# Imprimir el informe de clasificaci√≥n
print(classification_report(y_test, est.predict(X_test), zero_division=0))

"""###**M√ÅQUINA DE SOPORTE VECTORIAL**

LA MAQUINA DE SOPORTE VECTORIAL RESULTA CAER EN UNA COMPLEJIDAD ALTISIMA, SIENDO ASI QUE PARA DATOS DE 100MIL EN ADELANTE CUESTA MUCHO LOGRAR QUE COMPILE POR ENDE TOMAREMOS MUESTRAS DE 10MIL QUE DA UN ACCURACY BASTANTE SIMILAR A UNO OCN 100MIL DATOS (DEJE COMPILANDO LOS 100MIL DATOS Y GENERO 0.90)

ADEMAS EN SU KERNEL USAR POLY TAMBIEN AUMENTA MUCHO LA COMPLEJIDAD Y SU MEJORA NO ES TANTA POR ENDE ESTAREMOS EN LINEAR CON 10MIL DATOS PARA LAS PRUEBAS CON LA MSV
"""

def tpr(est,X,y):
    p = est.predict(X)
    return np.mean (p[y==1] == y[y==1])

def tnr(est,X,y):
    p = est.predict(X)
    return np.mean(p[y==0] == y[y==0])

"""PRIMER CASO SIN ALTERACIONES YA GENERA UN ACCURACY B UENO
PERO VIENDO EL RECALL EN REALIDAD LO HACE BASTANTE MAL
"""

from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# Reducci√≥n del tama√±o del conjunto de datos
subset_size = 10000  # Elige el tama√±o del subconjunto que deseas

X_subset = X[:subset_size]
y_subset = y[:subset_size]

# Divisi√≥n del subconjunto en datos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_subset, y_subset, test_size=0.2, shuffle=True, random_state=21)

# Creaci√≥n e entrenamiento del modelo SVM
est = SVC(kernel='linear', C=1.0, gamma='scale')
est.fit(X_train, y_train)

# Evaluaci√≥n del modelo en el subconjunto de prueba
y_pred = est.predict(X_test_correct)
accuracy = accuracy_score(y_test_correct, y_pred)
recall = recall_score(y_test_correct, y_pred)


print("Accuracy en el subconjunto de prueba:", accuracy)

print("Recall en el subconjunto de prueba:", recall)

"""MSV CON OVERSAMPLING
NOTAMOS UNA MEJORA CONSIDERABLE, DE 0 A 0.83 LO QUE ERA DE ESPERARSE YA QUE AL HABER DIVIDIDO LOS DATOS EN UN CONJUNTO DONDE  LA CLASE DE INTERES ES TAN BAJA QUE HAYA GENERADO 0 DE RECALL ERA NORMAL, PERO AHORA QUE LAS CLASES ESTAN IGUALADAS SE NOTA LA MEJORA.
"""

from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# Reducci√≥n del tama√±o del conjunto de datos
subset_size = 10000  # Elige el tama√±o del subconjunto que deseas

X_subset = X[:subset_size]
y_subset = y[:subset_size]


smote = SMOTE(sampling_strategy=1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)


# Divisi√≥n del subconjunto en datos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_resampled, y_resampled, test_size=0.2, shuffle=True, random_state=21)

# Creaci√≥n e entrenamiento del modelo SVM
est = SVC(kernel='linear', C=1.0, gamma='scale')
est.fit(X_train, y_train)

# Evaluaci√≥n del modelo en el subconjunto de prueba
y_pred = est.predict(X_test_correct)
accuracy = accuracy_score(y_test_correct, y_pred)
recall = recall_score(y_test_correct, y_pred)


print("Accuracy en el subconjunto de prueba:", accuracy)

print("Recall en el subconjunto de prueba:", recall)

"""MSV CON PCA SE MANTIENE IGUAL NO MEJORA NI EMPEORA"""

from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# Reducci√≥n del tama√±o del conjunto de datos
subset_size = 10000  # Elige el tama√±o del subconjunto que deseas

X_subset = X[:subset_size]
y_subset = y[:subset_size]


smote = SMOTE(sampling_strategy=1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)

X_pca = PCA(n_components=8)
X_pca = X_pca.fit_transform(X_resampled)

# Aplicar PCA al conjunto de prueba
x_train_pca = PCA(n_components=8)
X_test_correct_pca = x_train_pca.fit_transform(X_test_correct)

# Divisi√≥n del subconjunto en datos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_pca, y_resampled, test_size=0.2, shuffle=True, random_state=21)

# Creaci√≥n e entrenamiento del modelo SVM
est = SVC(kernel='linear', C=1.0, gamma='scale')
est.fit(X_train, y_train)

# Evaluaci√≥n del modelo en el subconjunto de prueba
y_pred = est.predict(X_test_correct_pca)
accuracy = accuracy_score(y_test_correct, y_pred)
recall = recall_score(y_test_correct, y_pred)


print("Accuracy en el subconjunto de prueba:", accuracy)

print("Recall en el subconjunto de prueba:", recall)

"""MSV + TSNE"""

from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, recall_score
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from imblearn.over_sampling import SMOTE

# Reducci√≥n del tama√±o del conjunto de datos
subset_size = 1000  # Elige el tama√±o del subconjunto que deseas

X_subset = X[:subset_size]
y_subset = y[:subset_size]

# Aplicar SMOTE a tus datos
smote = SMOTE(sampling_strategy=1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)

# Aplicar PCA a los datos resampleados
pca = PCA(n_components=8)
X_pca = pca.fit_transform(X_resampled)

# Aplicar t-SNE a los datos transformados por PCA
tsne = TSNE(n_components=2, random_state=42)
X_tsne = tsne.fit_transform(X_pca)

# Divisi√≥n del subconjunto en datos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_tsne, y_resampled, test_size=0.2, shuffle=True, random_state=21)

# Creaci√≥n e entrenamiento del modelo SVM
est = SVC(kernel='linear', C=1.0, gamma='scale')
est.fit(X_train, y_train)

# Evaluaci√≥n del modelo en el subconjunto de prueba
y_pred = est.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)

print("Accuracy en el subconjunto de prueba:", accuracy)
print("Recall en el subconjunto de prueba:", recall)

"""###**RANDOM FOREST CLASSIFIER (RFC)**"""

def tpr(est,X,y):
    p = est.predict(X)
    return np.mean (p[y==1] == y[y==1])

def tnr(est,X,y):
    p = est.predict(X)
    return np.mean(p[y==0] == y[y==0])

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import train_test_split
from sklearn.metrics import *

# Reducci√≥n del tama√±o del conjunto de datos
subset_size = 10000  # Ajusta el tama√±o seg√∫n sea necesario
X_subset, y_subset = X[:subset_size], y[:subset_size]

# Crear una instancia del clasificador RandomForest
est = RandomForestClassifier(n_estimators=100, random_state=21, max_depth=10)

# Dividir el conjunto de datos reducido para entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_subset, y_subset, test_size=0.2, shuffle=True, random_state=21)

# Entrenar el modelo en los datos reducidos
est.fit(X_train, y_train)

# Realizar la validaci√≥n cruzada con KFold
s = cross_val_score(est, X_train, y_train, cv=KFold(10, shuffle=True), scoring=make_scorer(accuracy_score), n_jobs=-1)
print("accuracy %.3f (+/- %.5f)" % (np.mean(s), np.std(s)))

# Tambi√©n puedes calcular la m√©trica de recall
s_recall = cross_val_score(est, X_test, y_test, cv=KFold(10, shuffle=True), scoring=make_scorer(recall_score), n_jobs=-1)
print("recall RFC %.3f (+/- %.5f)" % (np.mean(s_recall), np.std(s_recall)))

s = cross_val_score(est, X_test, y_test, cv=KFold(10, shuffle=True), scoring=tpr,n_jobs=-1)
print("tpr      %.3f (+/- %.5f)"%(np.mean(s), np.std(s)))
s = cross_val_score(est, X_subset, y_subset, cv=KFold(10, shuffle=True), scoring=tnr,n_jobs=-1)
print("tnr      %.3f (+/- %.5f)"%(np.mean(s), np.std(s)))

"""RFC AJUSTADO HACIENDO OVERSAMPLING A LOS DATOS"""

pip install -U imbalanced-learn

"""Y LOGRAMOS NUESTRO RECALL MAS ALTO HASTA AHORA DE 0.92 BASTANTE SIMILAR AL DECISION TREE CLASSIFIER PERO SUPERANDOLO POR POCO"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score, KFold
from sklearn.metrics import make_scorer, accuracy_score, recall_score
from imblearn.over_sampling import SMOTE


smote = SMOTE(sampling_strategy=1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)
# Crear una instancia del clasificador RandomForest
est = RandomForestClassifier(n_estimators=100, random_state=21,max_depth=10)

# Entrenar el modelo en los datos sobremuestreados
est.fit(X_resampled, y_resampled)

# Realizar la validaci√≥n cruzada con KFold
s = cross_val_score(est, X_test_correct, y_test_correct, cv=KFold(10, shuffle=True), scoring=make_scorer(accuracy_score))
print("accuracy %.3f (+/- %.5f)"%(np.mean(s), np.std(s)))

# Tambi√©n puedes calcular la m√©trica de recall
s_recall = cross_val_score(est, X_test_correct, y_test_correct, cv=KFold(10, shuffle=True), scoring=make_scorer(recall_score))
print("recall RFC %.3f (+/- %.5f)"%(np.mean(s_recall), np.std(s_recall)))

"""RFC + PCA DE 0.921 A 0.927"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score, KFold
from sklearn.metrics import make_scorer, accuracy_score, recall_score
from imblearn.over_sampling import SMOTE

smote = SMOTE(sampling_strategy=1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)
# Crear una instancia del clasificador RandomForest
est = RandomForestClassifier(n_estimators=40, random_state=21,max_depth=6)

X_pca = PCA(n_components=12)
X_pca = X_pca.fit_transform(X_resampled)

# Aplicar PCA al conjunto de prueba
x_train_pca = PCA(n_components=12)
X_test_correct_pca = x_train_pca.fit_transform(X_test_correct)

# Entrenar el modelo en los datos sobremuestreados
est.fit(X_pca, y_resampled)

# Realizar la validaci√≥n cruzada con KFold
s = cross_val_score(est, X_test_correct_pca, y_test_correct, cv=KFold(10, shuffle=True), scoring=make_scorer(accuracy_score))
print("accuracy %.3f (+/- %.5f)"%(np.mean(s), np.std(s)))

# Tambi√©n puedes calcular la m√©trica de recall
s_recall = cross_val_score(est, X_test_correct_pca, y_test_correct, cv=KFold(10, shuffle=True), scoring=make_scorer(recall_score))
print("recall RFC %.3f (+/- %.5f)"%(np.mean(s_recall), np.std(s_recall)))

"""RFC + TSNE"""

from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, recall_score
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from imblearn.over_sampling import SMOTE

# Reducci√≥n del tama√±o del conjunto de datos
subset_size = 1000  # Elige el tama√±o del subconjunto que deseas

X_subset = X[:subset_size]
y_subset = y[:subset_size]

# Aplicar SMOTE a tus datos
smote = SMOTE(sampling_strategy=1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_subset, y_subset)

# Aplicar PCA a los datos resampleados
pca = PCA(n_components=8)
X_pca = pca.fit_transform(X_resampled)

# Aplicar t-SNE a los datos transformados por PCA
tsne = TSNE(n_components=2, random_state=42)
X_tsne = tsne.fit_transform(X_pca)

# Divisi√≥n del subconjunto en datos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_tsne, y_resampled, test_size=0.2, shuffle=True, random_state=21)

# Creaci√≥n e entrenamiento del modelo SVM
est = SVC(kernel='linear', C=1.0, gamma='scale')
est.fit(X_train, y_train)

# Evaluaci√≥n del modelo en el subconjunto de prueba
y_pred = est.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)

print("Accuracy en el subconjunto de prueba:", accuracy)
print("Recall en el subconjunto de prueba:", recall)

"""###**DEEP NEURONAL NETWORK (DNN)**"""

import tensorflow as tf
from tensorflow import keras
from sklearn.model_selection import train_test_split

dataset = pd.read_csv("heart_dataset.csv", sep=",")
data_hc = dataset[['Age', 'DiffWalk', 'GenHlth', 'Stroke', 'HighChol', 'Diabetes', 'Smoker', 'PhysHlth', 'HighBP', 'Sex', 'PhysActivity', 'Education', 'Income', 'HeartDiseaseorAttack']]

X = data_hc.values[:,:-1]
y = data_hc.values[:,-1]
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2, shuffle= True, random_state=21)
print (X_train.shape, y_train.shape, X_test.shape, y_test.shape)

model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape= X_train[0].shape),
    tf.keras.layers.Dense(1024, activation=tf.nn.relu),
    tf.keras.layers.Dense(512, activation=tf.nn.relu),
    tf.keras.layers.Dense(256, activation=tf.nn.tanh),
    tf.keras.layers.Dense(128, activation=tf.nn.tanh),
    tf.keras.layers.Dense(64, activation=tf.nn.gelu),
    tf.keras.layers.Dense(32, activation=tf.nn.gelu),
    tf.keras.layers.Dense(2, activation=tf.nn.softmax)
])

model.summary()

model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=0.001),  #AdamOptimizer(),
              loss='sparse_categorical_crossentropy',
              metrics=["accuracy"])
model.fit(X_train, y_train, epochs=5)

test_loss, test_acc = model.evaluate(X_test, y_test)
print('Test accuracy:', test_acc)

from sklearn.metrics import classification_report


y_pred = model.predict(X_test)
y_pred_bool = np.argmax(y_pred, axis=1)

print(classification_report(y_test, y_pred_bool))

"""# **AVANCE APRENDIZAJE NO SUPERVISADO**"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.cluster import DBSCAN
from sklearn.model_selection import train_test_split
from sklearn.datasets import *
from sklearn.decomposition import PCA
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import *
from sklearn.ensemble import RandomForestClassifier
import tensorflow as tf
from tensorflow import keras
from sklearn.manifold import TSNE
from sklearn.tree import DecisionTreeClassifier

dataset = pd.read_csv("heart_dataset.csv", sep=",")
data_hc = dataset[['Age', 'DiffWalk', 'GenHlth', 'Stroke', 'HighChol', 'Diabetes', 'Smoker', 'PhysHlth', 'HighBP', 'Sex', 'PhysActivity', 'Education', 'Income', 'HeartDiseaseorAttack']]

X = data_hc.values[:,:-1]
y = data_hc.values[:,-1]
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2, shuffle= True, random_state=21)

"""# **KMeans**"""

plt.figure(figsize=(15,15))
plt(sns.heatmap(data_hc.corr(),annot=True, fmt=".2f",cmap="viridis"))

kmeans = KMeans(n_clusters=2)
kmeans.fit(X_train)
plt.figure(figsize=(10,10))

plt.subplot(131)
plt.title('KMeans')
plt.scatter(X_train[:,1],X_train[:,2], c=kmeans.labels_, cmap='rainbow')
plt.scatter(kmeans.cluster_centers_[:,0] ,kmeans.cluster_centers_[:,1], color='black')
plt.xlabel('DiffWalk')
plt.ylabel('GenHlth')
plt.subplot(132)
plt.scatter(X_train[:,1],X_train[:,7], c=kmeans.labels_, cmap='rainbow')
plt.scatter(kmeans.cluster_centers_[:,0] ,kmeans.cluster_centers_[:,1], color='black')
plt.xlabel('DiffWalk')
plt.ylabel('PhysHlth')
plt.subplot(133)
plt.scatter(X_train[:,2],X_train[:,7], c=kmeans.labels_, cmap='rainbow')
plt.scatter(kmeans.cluster_centers_[:,0] ,kmeans.cluster_centers_[:,1], color='black')
plt.xlabel('GenHlth')
plt.ylabel('PhysHlth')

"""# **DBScan**"""

from sklearn.preprocessing import StandardScaler

X = StandardScaler().fit_transform(X_train)
DBS = DBSCAN(eps=1)
DBS.fit(X[:10000,:])


plt.figure(figsize=(10,10))

plt.subplot(131)
plt.title('DBScan')
plt.scatter(X[:10000,1],X[:10000,2], c=DBS.labels_, cmap='rainbow')
plt.xlabel('DiffWalk')
plt.ylabel('GenHlth')
plt.subplot(132)
plt.scatter(X[:10000,1],X[:10000,7], c=DBS.labels_, cmap='rainbow')
plt.xlabel('DiffWalk')
plt.ylabel('PhysHlth')
plt.subplot(133)
plt.scatter(X[:10000,2],X[:10000,7], c=DBS.labels_, cmap='rainbow')
plt.xlabel('GenHlth')
plt.ylabel('PhysHlth')

pca_hc = PCA(n_components= 4, whiten=True)
X_pca_train = pca_hc.fit_transform(X_train)
X_pca_test = pca_hc.fit_transform(X_test)

est = GaussianNB()

est.fit(X_pca_train,y_train)
y_pred = est.predict(X_pca_test)
print(classification_report(y_test, y_pred))

est = DecisionTreeClassifier(max_depth=6)
est.fit(X_pca_train,y_train)
print(classification_report(y_test, est.predict(X_pca_test), zero_division=0))

model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape= X_pca_train[0].shape),
    tf.keras.layers.Dense(1024, activation=tf.nn.relu),
    tf.keras.layers.Dense(512, activation=tf.nn.relu),
    tf.keras.layers.Dense(256, activation=tf.nn.tanh),
    tf.keras.layers.Dense(128, activation=tf.nn.tanh),
    tf.keras.layers.Dense(64, activation=tf.nn.gelu),
    tf.keras.layers.Dense(32, activation=tf.nn.gelu),
    tf.keras.layers.Dense(2, activation=tf.nn.softmax)
])

model.summary()

model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=0.001),  #AdamOptimizer(),
              loss='sparse_categorical_crossentropy',
              metrics=["accuracy"])
model.fit(X_pca_train, y_train, epochs=5)

y_pred = model.predict(X_pca_test)
y_pred_bool = np.argmax(y_pred, axis=1)

print(classification_report(y_test, y_pred_bool))

est = RandomForestClassifier(n_estimators=100, random_state=21, max_depth=10)
est.fit(X_pca_train,y_train)
y_pred = est.predict(X_pca_test)
print(classification_report(y_test, y_pred))

tsne_hc = TSNE(n_components=2)
X_pca_tsne_train =  tsne_hc.fit(X_pca_train[:10000,:])
X_pca_tsne_test =  tsne_hc.fit(X_pca_test[:10000,:])

est = DecisionTreeClassifier(max_depth=6)
est.fit(X_pca_tsne_train,y_train[:10000])
print(classification_report(y_test[:10000], est.predict(X_pca_tsne_test), zero_division=0))

est = RandomForestClassifier(n_estimators=100, random_state=21, max_depth=10)
est.fit(X_pca_tsne_train,y_train[:10000])
y_pred = est.predict(X_pca_tsne_test)
print(classification_report(y_test[:10000], y_pred))

model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape= X_pca_train[0].shape),
    tf.keras.layers.Dense(1024, activation=tf.nn.relu),
    tf.keras.layers.Dense(512, activation=tf.nn.relu),
    tf.keras.layers.Dense(256, activation=tf.nn.tanh),
    tf.keras.layers.Dense(128, activation=tf.nn.tanh),
    tf.keras.layers.Dense(64, activation=tf.nn.gelu),
    tf.keras.layers.Dense(32, activation=tf.nn.gelu),
    tf.keras.layers.Dense(2, activation=tf.nn.softmax)
])

model.summary()

model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=0.001),  #AdamOptimizer(),
              loss='sparse_categorical_crossentropy',
              metrics=["accuracy"])
model.fit(X_pca_train, y_train, epochs=5)

y_pred = model.predict(X_pca_test)
y_pred_bool = np.argmax(y_pred, axis=1)

print(classification_report(y_test, y_pred_bool))